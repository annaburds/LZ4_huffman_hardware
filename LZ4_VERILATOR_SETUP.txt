================================================================================
                    COMPLETE VERILATOR SETUP GUIDE
================================================================================

This document contains all code needed to run LZ4 with Verilator.
Copy-paste ready. Estimated time: 6-8 hours.

================================================================================
                    PART 1: BEHAVIORAL IP MODULES
================================================================================

Copy these 6 files into: LZ4_huffman_IPS/behavioral/

─────────────────────────────────────────────────────────────────────────────
FILE 1: hash_mul32x32_behavioral.v
─────────────────────────────────────────────────────────────────────────────

`timescale 1ns / 1ps

// Behavioral replacement for Xilinx DSP48E multiplier
// Used for hash calculation: product = data × 0x9E3779B1

module hash_mul32x32 (
    input  wire        CLK,
    input  wire        A_sel,      // Not used in behavioral
    input  wire        B_sel,      // Not used in behavioral
    input  wire        CE,         // Not used in behavioral
    input  wire        SCLR,       // Not used in behavioral
    
    input  wire [31:0] A,
    input  wire [31:0] B,
    output wire [63:0] P
);
    // Behavioral multiply - Verilator will synthesize
    assign P = A * B;
    
    // Note: No pipeline latency in behavioral model
    // For accurate timing, add registered output:
    // (Uncomment if needed)
    /*
    reg [63:0] P_reg;
    always @(posedge CLK) 
        if (!SCLR) P_reg <= A * B;
    assign P = P_reg;
    */
endmodule

─────────────────────────────────────────────────────────────────────────────
FILE 2: xxh32_mul_behavioral.v
─────────────────────────────────────────────────────────────────────────────

`timescale 1ns / 1ps

module xxh32_mul (
    input  wire        CLK,
    input  wire        A_sel,      // Not used
    input  wire        B_sel,      // Not used
    input  wire        CE,         // Not used
    input  wire        SCLR,       // Not used
    
    input  wire [31:0] A,
    input  wire [31:0] B,
    output wire [63:0] P
);
    assign P = A * B;
endmodule

─────────────────────────────────────────────────────────────────────────────
FILE 3: hash_ram_32Kx64bit_behavioral.v
─────────────────────────────────────────────────────────────────────────────

`timescale 1ns / 1ps

// Behavioral dual-port SRAM (32K × 65-bit)
// Used for hash dictionary (4-port virtualized via time-multiplexing)

module hash_ram_32Kx64bit (
    input  wire        clka,
    input  wire        clkb,
    input  wire        rsta,       // Not used
    input  wire        rstb,       // Not used
    input  wire [14:0] addra,
    input  wire [14:0] addrb,
    input  wire [64:0] dina,
    input  wire [64:0] dinb,
    input  wire        wea,
    input  wire        web,
    input  wire        enb,        // Not used
    output reg  [64:0] douta,
    output reg  [64:0] doutb
);
    // Storage array: 32K words × 65 bits
    reg [64:0] mem [0:32767];
    
    // Port A: Read/Write
    always @(posedge clka) begin
        if (wea) begin
            mem[addra] <= dina;
        end
        // Registered output (1-cycle latency)
        douta <= mem[addra];
    end
    
    // Port B: Read/Write (identical to Port A)
    always @(posedge clkb) begin
        if (web) begin
            mem[addrb] <= dinb;
        end
        // Registered output (1-cycle latency)
        doutb <= mem[addrb];
    end
    
    // Optional: Initialize to zero
    initial begin
        integer i;
        for (i = 0; i < 32768; i = i + 1)
            mem[i] = 65'h0;
    end
endmodule

─────────────────────────────────────────────────────────────────────────────
FILE 4: buffer_ram32Kx32bit_behavioral.v
─────────────────────────────────────────────────────────────────────────────

`timescale 1ns / 1ps

// Behavioral dual-port SRAM (32K × 32-bit)
// Used for input buffer (64KB total = 2 blocks)

module buffer_ram32Kx32bit (
    input  wire        clka,
    input  wire        clkb,
    input  wire        rsta,       // Not used
    input  wire        rstb,       // Not used
    input  wire [14:0] addra,
    input  wire [14:0] addrb,
    input  wire [31:0] dina,
    input  wire [31:0] dinb,
    input  wire        wea,
    input  wire        web,
    input  wire        enb,        // Not used
    output reg  [31:0] douta,
    output reg  [31:0] doutb
);
    reg [31:0] mem [0:32767];
    
    // Port A
    always @(posedge clka) begin
        if (wea) mem[addra] <= dina;
        douta <= mem[addra];
    end
    
    // Port B
    always @(posedge clkb) begin
        if (web) mem[addrb] <= dinb;
        doutb <= mem[addrb];
    end
    
    initial begin
        integer i;
        for (i = 0; i < 32768; i = i + 1)
            mem[i] = 32'h0;
    end
endmodule

─────────────────────────────────────────────────────────────────────────────
FILE 5: fifo_512x47bit_behavioral.v
─────────────────────────────────────────────────────────────────────────────

`timescale 1ns / 1ps

// Behavioral FIFO (512 × 47-bit)
// Purpose: Conflict resolution in buffer

module fifo_512x47bit (
    input  wire        clk,
    input  wire        rst,        // Unused (use rstN)
    input  wire        rstN,       // Active-low reset
    input  wire [46:0] din,
    input  wire        wr_en,
    output wire [46:0] dout,
    input  wire        rd_en,
    output wire        full,
    output wire        empty,
    output wire [9:0]  wr_data_count,
    output wire [9:0]  rd_data_count,
    output wire [9:0]  data_count
);
    reg [46:0] fifo_mem [0:511];
    reg [9:0]  wr_ptr;
    reg [9:0]  rd_ptr;
    reg [10:0] count;  // 11 bits to detect full condition
    
    always @(posedge clk or negedge rstN) begin
        if (!rstN) begin
            wr_ptr <= 10'b0;
            rd_ptr <= 10'b0;
            count  <= 11'b0;
        end else begin
            // Write logic
            if (wr_en && !full) begin
                fifo_mem[wr_ptr] <= din;
                wr_ptr <= wr_ptr + 1;
                count <= count + 1;
            end
            
            // Read logic
            if (rd_en && !empty) begin
                rd_ptr <= rd_ptr + 1;
                count <= count - 1;
            end
            
            // Handle simultaneous read/write
            if (wr_en && rd_en && !empty) begin
                // Pointer updates cancel out, count stays same
                wr_ptr <= wr_ptr + 1;
                rd_ptr <= rd_ptr + 1;
            end
        end
    end
    
    assign dout = fifo_mem[rd_ptr];
    assign full = (count == 11'd512);
    assign empty = (count == 11'b0);
    assign data_count = count[9:0];
    assign wr_data_count = count[9:0];
    assign rd_data_count = count[9:0];
endmodule

─────────────────────────────────────────────────────────────────────────────
FILE 6: hash_pll_behavioral.v
─────────────────────────────────────────────────────────────────────────────

`timescale 1ns / 1ps

// Behavioral replacement for Xilinx PLL
// In Verilator, we don't synthesize PLLs
// Instead, provide two independent clocks from testbench

module hash_pll (
    input  wire CLK_IN1,    // 250 MHz input (unused in behavioral)
    input  wire RST,        // Reset (unused)
    
    output wire CLK_500,    // 500 MHz output (provided externally)
    output wire LOCKED      // PLL locked flag
);
    // In simulation, this PLL is "always locked"
    // The actual 500 MHz clock must be provided by testbench
    assign LOCKED = 1'b1;
    
    // Note: CLK_500 output is not driven here
    // Testbench must connect external 500MHz clock signal
    // (This is a behavioral stub - no clock generation)
endmodule


================================================================================
                    PART 2: VERILATOR BUILD SYSTEM
================================================================================

─────────────────────────────────────────────────────────────────────────────
FILE 7: Makefile
─────────────────────────────────────────────────────────────────────────────

Save as: LZ4_huffman_SIM/verilator/Makefile

VERILATOR = verilator
VERILATOR_FLAGS = -Wall --trace --cc
CXX = g++
CXXFLAGS = -std=c++11 -O2

# Path to source files
CORE_RTL = ../../LZ4_huffman_CORE/02.rtl/lz4
IP_BEHAV = ../../LZ4_huffman_IPS/behavioral

# Source files
LZ4_FILES = \
    $(CORE_RTL)/lz4_top_v3.v \
    $(CORE_RTL)/control_fsm_v3.v \
    $(CORE_RTL)/hash_table_v3.v \
    $(CORE_RTL)/lz4_encoder_v3.v \
    $(CORE_RTL)/lz4_buffer_v2.v \
    $(CORE_RTL)/byte_addressing_v4.v \
    $(CORE_RTL)/xxh32_calc_v2.v \
    $(CORE_RTL)/abs_addr_gen_v3.v \
    $(CORE_RTL)/hash_4port_32Kx65bit.v \
    $(CORE_RTL)/hash_match.v \
    $(CORE_RTL)/shifter_match.v \
    $(CORE_RTL)/shifter_prefetch.v \
    $(CORE_RTL)/unmatch_fifo_v3.v

IP_FILES = \
    $(IP_BEHAV)/hash_mul32x32_behavioral.v \
    $(IP_BEHAV)/xxh32_mul_behavioral.v \
    $(IP_BEHAV)/hash_ram_32Kx64bit_behavioral.v \
    $(IP_BEHAV)/buffer_ram32Kx32bit_behavioral.v \
    $(IP_BEHAV)/fifo_512x47bit_behavioral.v \
    $(IP_BEHAV)/hash_pll_behavioral.v

TB_FILES = verilator_tb.v

ALL_FILES = $(LZ4_FILES) $(IP_FILES) $(TB_FILES)

# Top-level module
TOP = lz4_top_v3

# Output executable
EXE = obj_dir/V$(TOP)

# Targets
all: verilate compile sim

verilate: $(ALL_FILES)
	$(VERILATOR) $(VERILATOR_FLAGS) \
		-I$(CORE_RTL) \
		-I$(IP_BEHAV) \
		-I. \
		--top-module $(TOP) \
		$(ALL_FILES)

compile:
	$(MAKE) -C obj_dir -f V$(TOP).mk

sim: compile
	$(EXE)

clean:
	rm -rf obj_dir *.o

.PHONY: all verilate compile sim clean


─────────────────────────────────────────────────────────────────────────────
FILE 8: verilator_tb.v (Minimal)
─────────────────────────────────────────────────────────────────────────────

Save as: LZ4_huffman_SIM/verilator/verilator_tb.v

`timescale 1ns / 1ps

module verilator_tb;
    // Input signals
    reg           clk;
    reg           clk_2x;
    reg           rstN;
    reg  [31:0]   idata;
    reg           idata_req;
    reg           data_terminal;
    reg           start_compress;
    reg  [31:0]   file_length;
    reg           file_length_valid;
    reg           out_en;
    
    // Output signals
    wire          mfifo_full;
    wire          mfifo_empty;
    wire [33:0]   out_data;
    wire          out_empty;
    wire          out_valid;
    wire          obuf_full;
    wire          ohalf_full;
    wire          compress_done;
    wire [31:0]   compressed_len;
    
    // Test interface
    wire          mfifo_valid;
    wire [31:0]   mfifo_data;
    
    // DUT instantiation
    lz4_top_v3 uut (
        .clk(clk),
        .rstN(rstN),
        .idata(idata),
        .idata_req(idata_req),
        .data_terminal(data_terminal),
        .start_compress(start_compress),
        .mfifo_full(mfifo_full),
        .mfifo_empty(mfifo_empty),
        .file_length(file_length),
        .file_length_valid(file_length_valid),
        .out_en(out_en),
        .out_data(out_data),
        .out_empty(out_empty),
        .out_valid(out_valid),
        .obuf_full(obuf_full),
        .ohalf_full(ohalf_full),
        .compress_done(compress_done),
        .compressed_len(compressed_len),
        .mfifo_valid(mfifo_valid),
        .mfifo_data(mfifo_data)
    );
    
    // Clock generation: 250 MHz
    initial clk = 0;
    always #2 clk = ~clk;  // 4ns period = 250 MHz
    
    // Clock generation: 500 MHz (independent)
    initial clk_2x = 0;
    always #1 clk_2x = ~clk_2x;  // 2ns period = 500 MHz
    
    // Test stimulus
    initial begin
        // Initialize
        rstN = 0;
        idata = 0;
        idata_req = 0;
        data_terminal = 0;
        start_compress = 0;
        file_length = 0;
        file_length_valid = 0;
        out_en = 0;
        
        // Reset sequence
        #100;
        rstN = 1;
        
        // Wait for PLL to lock (simulated instant)
        #100;
        
        // Start compression
        start_compress = 1;
        #4;
        start_compress = 0;
        
        // Simulate data input (simple example)
        #20;
        idata = 32'h12345678;
        idata_req = 1;
        #4;
        idata_req = 0;
        
        // Wait for completion
        #100000;
        
        // Finish simulation
        $display("Simulation complete at time %0t", $time);
        $finish;
    end
    
    // Optional: Generate VCD trace for waveform analysis
    initial begin
        $dumpfile("lz4_sim.vcd");
        $dumpvars(0, verilator_tb);
    end
endmodule


================================================================================
                    PART 3: RUNNING THE SIMULATION
================================================================================

STEP 1: Install Verilator
──────────────────────────
$ sudo apt-get install verilator
$ verilator --version  # Verify installation


STEP 2: Create Directory Structure
───────────────────────────────────
mkdir -p LZ4_huffman_CORE/02.rtl/lz4
mkdir -p LZ4_huffman_IPS/behavioral
mkdir -p LZ4_huffman_SIM/verilator


STEP 3: Copy Files
───────────────────
# Copy custom RTL files
cp -r /home/burdina/projects/LZ4_huffman/02.rtl/lz4/*.v \
      LZ4_huffman_CORE/02.rtl/lz4/

# Copy IP behavioral stubs (from PART 1 above)
cp *.v LZ4_huffman_IPS/behavioral/

# Copy build files (from PART 2 above)
cp Makefile verilator_tb.v LZ4_huffman_SIM/verilator/


STEP 4: Build & Run
────────────────────
$ cd LZ4_huffman_SIM/verilator/
$ make clean
$ make

# Output should be:
# - obj_dir/ directory created
# - Vlz4_top_v3 executable generated
# - Simulation runs automatically


STEP 5: Check Output
─────────────────────
$ ls -lh obj_dir/Vlz4_top_v3
$ ./obj_dir/Vlz4_top_v3  # Run directly
$ ls -lh lz4_sim.vcd     # Waveform trace file


================================================================================
                    PART 4: TROUBLESHOOTING
================================================================================

ERROR: "hash_mul32x32" not found
───────────────────────────────
Cause: Verilator can't find behavioral IP module
Fix: Check Makefile -I flags point to behavioral/ directory
     Verify IP files are in correct location


ERROR: Port name mismatch
──────────────────────────
Cause: Behavioral IP has different port names
Fix: Check original Xilinx core port names
     Rename behavioral ports to match


ERROR: Undefined clock clk_2x
─────────────────────────────
Cause: PLL stub doesn't generate clock
Fix: Make sure testbench generates both clk and clk_2x
     Connect external clk_2x signal in top-level


ERROR: Memory too large
───────────────────────
Cause: Verilator can't handle 32K×65-bit array
Fix: Use smaller test case first
     Check Verilator memory limits
     May need external memory model


================================================================================
                    PART 5: OPTIMIZATION (Optional)
================================================================================

To speed up simulation significantly, create C++ harness:

FILE 9: verilator_tb.cpp

#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Vlz4_top_v3.h"

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    
    Vlz4_top_v3* dut = new Vlz4_top_v3;
    
    // Open VCD file
    VerilatedVcdC* tfp = NULL;
    if (true) {  // Enable tracing
        tfp = new VerilatedVcdC;
        dut->trace(tfp, 99);
        tfp->open("lz4_sim.vcd");
    }
    
    // Reset sequence
    dut->rstN = 0;
    dut->clk = 0;
    dut->clk_2x = 0;
    
    for (int i = 0; i < 100; i++) {
        dut->eval();
        if (tfp) tfp->dump(i * 10);
    }
    
    dut->rstN = 1;
    
    // Run simulation
    for (int i = 100; i < 1000000; i++) {
        dut->clk = (i % 2 == 0) ? 0 : 1;
        dut->clk_2x = (i % 4 == 0) ? 0 : 1;
        
        dut->eval();
        if (tfp) tfp->dump(i * 10);
        
        if (dut->compress_done) {
            printf("Compression done at cycle %d\\n", i);
            break;
        }
    }
    
    if (tfp) tfp->close();
    delete dut;
    return 0;
}

To compile with C++ harness, add to Makefile:
    VERILATOR_FLAGS += --exe verilator_tb.cpp
    compile:
        $(MAKE) -C obj_dir -f V$(TOP).mk CXX_OPTS="-O2"


================================================================================
                    PART 6: VERIFICATION
================================================================================

After simulation completes, verify:

1. Check for errors in simulation log
2. Review VCD waveform if generated (lz4_sim.vcd)
3. Confirm compress_done signal pulses
4. Check output signals transition correctly

To view waveforms:
    gtkwave lz4_sim.vcd

Select signals to monitor:
    - clk, clk_2x (clock domains)
    - rstN (reset)
    - compress_done (completion)
    - out_valid, out_data (output data)
    - mfifo_full, mfifo_empty (buffer status)


================================================================================
                    SUMMARY
================================================================================

Files to Create: 9 total
    - 6 behavioral IP modules
    - 1 Makefile
    - 1 Verilator testbench
    - Optional 1 C++ harness

Time to Implement: 6-8 hours total
    - IP stubs: 2-3 hours
    - Build system: 1-2 hours
    - Debugging: 2-3 hours
    - Verification: 1 hour

End Result: Full LZ4 compression working in Verilator simulator

Benefits:
    ✓ 100-1000× faster simulation than FPGA
    ✓ No Xilinx tools needed
    ✓ Portable (runs on any Linux machine)
    ✓ Same test files as FPGA version
    ✓ Easy to debug (VCD waveforms)
    ✓ Can integrate into CI/CD pipeline

================================================================================
