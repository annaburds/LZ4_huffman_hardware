================================================================================
                    LZ4 HARDWARE HIERARCHY DOCUMENTATION INDEX
================================================================================

This package contains comprehensive documentation of the LZ4 hardware
compression implementation from the LZ4_huffman_hardware repository.

Generated: January 15, 2026
Repository: weslay-koo/LZ4_huffman_hardware
Branch: master
Target: Xilinx FPGA (Verilog HDL)


DOCUMENT FILES IN THIS SET:
================================================================================

1. LZ4_HIERARCHY.txt (This file's companion - Main Overview)
   ├─ Complete module hierarchy tree
   ├─ Data flow architecture diagram
   ├─ Xilinx IP cores inventory (33 total)
   ├─ Signal handshaking protocols
   ├─ Module dependency graph
   └─ Key design patterns
   
   USE THIS FOR: Understanding overall architecture and module relationships

2. LZ4_SIGNAL_TIMING.txt (Detailed Timing & Signals)
   ├─ Pipeline stage breakdown (7 stages)
   ├─ Signal bus widths (all 34 major signals)
   ├─ Latency analysis per stage
   ├─ Clock domain specifications
   ├─ Memory hierarchy
   ├─ Design efficiency metrics
   └─ Cycle-by-cycle progression example
   
   USE THIS FOR: Detailed signal specifications and timing analysis

3. LZ4_INSTANTIATION_MAP.txt (IP & Module Connections)
   ├─ Actual Verilog instantiation details
   ├─ Port mappings for all modules
   ├─ Data flow paths (input, hash, control, encoding)
   ├─ Xilinx IP core port specifications
   ├─ Naming conventions & coding styles
   └─ Module instantiation examples
   
   USE THIS FOR: Understanding exact port connections and IP specifications

4. LZ4_QUICK_REFERENCE.txt (Summary & Integration Guide)
   ├─ Compressed overview (visual hierarchy)
   ├─ Key facts summary
   ├─ Algorithm highlights
   ├─ FSM state flow diagram
   ├─ Interface timing examples
   ├─ Debug monitoring points
   └─ Integration checklist for ASIC/system
   
   USE THIS FOR: Quick lookup and integration planning


SOURCE CODE LOCATIONS:
================================================================================

Main LZ4 Implementation:
  /mix_compress_v1/RTL_lz4/
  ├─ lz4_top_v3.v ..................... Top-level module (372 lines)
  ├─ control_fsm_v3.v ................. Main FSM orchestrator (1714 lines) ★
  ├─ hash_table_v3.v .................. 4-parallel hash engine (707 lines) ★
  ├─ lz4_encoder_v3.v ................. Block format encoder (972 lines) ★
  ├─ lz4_buffer_v2.v .................. 64KB sliding window (721 lines) ★
  ├─ byte_addressing_v4.v ............. Barrel shifter (554 lines)
  ├─ xxh32_calc_v2.v .................. Checksum calculator (1254 lines)
  ├─ abs_addr_gen_v3.v ................ Address generator (56 lines)
  │
  └─ ipcores/ (19 Xilinx IP cores)
     ├─ bram_512x47bit/
     ├─ buffer_ram32Kx32bit/
     ├─ fifo_*.v (various sizes)
     ├─ hash_ram_32Kx*.v
     ├─ hash_mul32x32.v
     ├─ hash_pll.v
     ├─ unmatch_ram_*.v
     └─ xxh32_mul.v

Huffman Compression (Parallel path):
  /mix_compress_v1/RTL_huffman/
  ├─ huffman_encoder_v5.v ............. Main Huffman encoder (933 lines)
  ├─ tree_build_v3.v
  ├─ code_length.v
  ├─ bit_len_gen.v
  ├─ vlc_glue_v4.v
  └─ ipcores/ (14 Xilinx IP cores)

Multiplexer (LZ4 + Huffman):
  /mix_compress_v1/RTL_mux/
  ├─ mix_compression_top.v ............ Combined LZ4+Huffman encoder
  ├─ mode_select.v
  └─ cascade_logic.v

★ Most critical modules for understanding LZ4 operation


KEY STATISTICS:
================================================================================

Code Metrics:
  • Total RTL lines: ~6,800 (Verilog)
  • Custom logic: ~4,200 lines
  • Xilinx IP: 33 instances
  • Module count: 69 (custom modules)
  • Test benches: ~20 simulation files

Module Size Distribution:
  Largest:  xxh32_calc_v2.v (1254 lines)
  Large:    control_fsm_v3.v (1714 lines) - Most complex FSM
  Large:    lz4_encoder_v3.v (972 lines)
  Large:    lz4_buffer_v2.v (721 lines)
  Large:    hash_table_v3.v (707 lines)
  Medium:   byte_addressing_v4.v (554 lines)
  Small:    Various <200 line support modules

Memory Usage:
  • SRAM on-chip: ~380 KB
    ├─ Buffer (data): 64 KB
    ├─ Hash table (dictionary): 256 KB
    ├─ FIFOs: ~50 KB
    └─ Other: ~10 KB

Xilinx IP Breakdown:
  Memory: 14 blocks (BRAM/dual-port RAM)
  Compute: 2 multiplier IP cores (×4 instances each)
  Clock: 1 PLL
  Total: 19 primary instances (33 if counting sub-blocks)


ALGORITHM IMPLEMENTATION:
================================================================================

LZ4 Features Supported:
  ✓ Sliding window (64 KB)
  ✓ Hash-based dictionary (32K entries)
  ✓ 4-byte minimum match
  ✓ Variable-length encoding
  ✓ Full LZ4 frame format
  ✓ XXHash32 checksum
  ✓ Parallel matching (4-way)
  ✓ Streaming compression

Hardware Features:
  ✓ Pipeline: 7 stages
  ✓ Clock doubling: 250 MHz → 500 MHz for hash
  ✓ Throughput: 250 MB/s theoretical @ 250 MHz
  ✓ Latency: ~7-10 cycles (match decision)
  ✓ Dual-clock domain (CDC included)
  ✓ Full backpressure/handshaking


DATAFLOW SUMMARY:
================================================================================

Input → [Buffer] → [Shifter] → [Hash] → [SRAM] → [FSM] → [Encoder] → Output
  32b    64KB      96-bit     4× mul   32Kx64   Control  LZ4 fmt    34b
         SRAM      register   DSP      SRAM     FSM      Tokens     compressed

Parallel: [XXHash32] → Checksum appended to frame


CRITICAL PERFORMANCE FACTORS:
================================================================================

1. Hash Calculation Latency (3-5 cycles @ 500 MHz):
   - Pipelined in DSP48E multiplier
   - Limits throughput if not well-pipelined
   - Mitigated by 4-parallel lookups per cycle

2. SRAM Access Latency (2 cycles):
   - Registered output from Xilinx BRAM
   - Built-in delay, not optimizable
   - Pipeline stage absorbs delay

3. FSM Decision Time (1 cycle):
   - Control logic arbitrates 4 match candidates
   - Select best match (longest, closest)
   - Negligible delay vs. hash/SRAM

4. Encoder Output Rate (Variable):
   - Short tokens: 2-4 cycles per block
   - Long matches: 10-15 cycles (variable-length)
   - Average: 3-5 cycles per match/literal


COMPARISON TO OTHER IMPLEMENTATIONS:
================================================================================

Software (CPU):
  • Throughput: 20-100 MB/s typical
  • Latency: 100-1000 cycles per match
  • Flexibility: Full algorithm control

Hardware (FPGA - This Design):
  • Throughput: 125-250 MB/s
  • Latency: 7-10 cycles per match
  • Tradeoff: Fixed architecture

Hardware (ASIC - Potential):
  • Throughput: 500+ MB/s (optimized)
  • Latency: 5-8 cycles
  • Cost: High (custom design)


MIGRATION TO ASIC:
================================================================================

Xilinx IP Cores to Replace:
  [ ] bram_512x47bit → SRAM compiler dual-port
  [ ] buffer_ram32Kx32bit → SRAM compiler (2× instances)
  [ ] hash_ram_32Kx64bit → SRAM compiler (2× instances)
  [ ] fifo_*.v modules → Custom FIFO with SRAM
  [ ] hash_mul32x32 → Multiplier from standard cell lib
  [ ] xxh32_mul → Multiplier from standard cell lib
  [ ] hash_pll → ASIC PLL/clock tree or external clock

Modules That Can Stay As-Is:
  ✓ All FSM logic (control_fsm_v3, etc.)
  ✓ Encoding logic (lz4_encoder_v3)
  ✓ Hash computation (algorithm stays, just replace multiplier)
  ✓ Address generation
  ✓ Data flow logic

Estimated ASIC Effort:
  • IP replacement: 2-4 weeks (foundry tools)
  • Verification: 3-4 weeks (simulation, P&R)
  • Total: ~6-8 weeks

Area Estimate (45nm CMOS):
  • SRAM: ~2 mm² (380 KB)
  • Logic: ~1-2 mm²
  • Total: ~3-4 mm² die area


COMMON QUESTIONS:
================================================================================

Q: Why 4-parallel hash matching?
A: Exploits BRAM 4-port capability and allows 1 decision per cycle.
   Without it, only 1 match found per 4 cycles.

Q: Why clock doubling (500 MHz)?
A: Hash multiply is fast (3-5 cycle latency). At 250 MHz, only 1 hash
   calculation happens per cycle. At 500 MHz on hash_table, 4 complete
   in parallel, matching the 4 byte shifts.

Q: Why not check all 64KB dictionary?
A: Cost prohibitive (would need massive CAM - Content Addressable Memory).
   Hash-based approach achieves 90%+ of compression ratio with 1/100 area.

Q: What happens on hash collision?
A: Old entry overwritten by new one. Simple but effective for LZ4 where
   any match beats no match. More recent data usually compresses better.

Q: Can this be pipelined further?
A: Limited by SRAM latency (2 cycles - Xilinx BRAM inherent).
   Possible to decouple FSM from SRAM to 6+ stages, but SRAM read becomes
   bottleneck. Current 7-stage design is near-optimal.

Q: What about real-time operation?
A: Not hard real-time. Variable-length encoding causes jitter in output
   rate (2-15 cycles depending on match length). Suitable for bulk
   compression, not low-latency streaming.

Q: How to verify correctness?
A: Compare output with software LZ4 reference implementation.
   Simulation test benches provided in /simulation/ directory.
   Can also decompress output with standard LZ4 tools.


TESTING & VERIFICATION:
================================================================================

Test Benches Available:
  • lz4_top_tb.v ................... Top-level stimulus
  • control_fsm_tb.v (variant) ..... FSM verification
  • hash_table_tb.v ................ Hash function testing
  • byte_addressing_tb_v2.v ........ Shifter unit test
  • Various others in /simulation/

Simulation Setup:
  • Tool: Xilinx ISE (ISim) or Vivado
  • Language: Verilog
  • Simulator: Event-driven (ISim)
  • Typical run time: 1-10 minutes for full file

Verification Coverage:
  • Functional: Hash lookup correctness
  • Integration: End-to-end compression
  • Regression: Multiple file types

Known Limitations:
  • Simulation 100× slower than real hardware
  • Large file compression takes hours
  • Test vectors manually created


REFERENCE DOCUMENTATION:
================================================================================

External Resources:

LZ4 Standard:
  https://github.com/lz4/lz4/blob/master/doc/lz4_Frame_format.md
  https://github.com/lz4/lz4/wiki/lz4_Block_format

XXHash32:
  https://github.com/Cyan4973/xxHash

Xilinx FPGA Tools:
  ISE Design Suite documentation
  Vivado design tools
  BRAM/DSP compiler guides


CONTACT & SUPPORT:
================================================================================

Repository: https://github.com/weslay-koo/LZ4_huffman_hardware
Author: weslay-koo
License: Check LICENSE file in repository

Project Status: 
  • LZ4 encoder: Complete & tested
  • Huffman encoder: Complete & tested
  • Combined system: Complete & tested
  • ASIC port: Reference design only (not taped out)


DOCUMENT CROSS-REFERENCES:
================================================================================

Need to understand...                See section in...
─────────────────────────────────────────────────────────────────
Module connections                    LZ4_INSTANTIATION_MAP.txt
Signal timing and latency             LZ4_SIGNAL_TIMING.txt
Module dependencies                   LZ4_HIERARCHY.txt
Algorithm implementation              LZ4_QUICK_REFERENCE.txt
FSM state flow                        LZ4_QUICK_REFERENCE.txt
System integration                    LZ4_QUICK_REFERENCE.txt
Clock domains                         LZ4_SIGNAL_TIMING.txt
Memory organization                   LZ4_SIGNAL_TIMING.txt
Data flow example                     LZ4_QUICK_REFERENCE.txt
ASIC migration plan                   Previous analysis
IP core specifications                LZ4_INSTANTIATION_MAP.txt


VERSION HISTORY:
================================================================================

Documentation Version: 1.0
Generated: January 15, 2026
Covers: LZ4_huffman_hardware v1.0 (master branch)

RTL Versions Referenced:
  • lz4_top_v3 ................. Preferred version
  • lz4_encoder_v3 ............ Preferred version
  • control_fsm_v3 ............ Preferred version
  • hash_table_v3 ............. Preferred version
  • byte_addressing_v4 ........ Preferred version
  • lz4_buffer_v2 ............. Preferred version
  • xxh32_calc_v2 ............. Preferred version

Legacy Versions Available (Not recommended for new designs):
  • lz4_top v1, v2
  • lz4_encoder v1, v2
  • hash_table v1, v2
  • byte_addressing v1, v2, v3


NOTES:
================================================================================

1. All clock frequencies assume Xilinx 7-series or newer FPGA family.

2. Timing analysis based on Xilinx IP core datasheets for equivalent
   devices (Virtex-7 or Kintex-7 grade).

3. Power numbers are estimates based on activity factors. Actual depends
   on data characteristics and placement/routing.

4. Area estimates for ASIC migration are rough and foundry-dependent.
   Actual results vary by:
   • Technology node
   • Foundry standard cell library
   • Place & route optimization
   • Memory compiler used

5. Some modules (dated 2016) have very thorough comments in source code.
   Refer to actual .v files for implementation details.

6. The design uses active-low reset convention throughout (rstN).
   Ensure proper synchronizer on reset entry to design.

7. All internal clocking uses Xilinx differential clock inputs for
   jitter reduction. Critical for hash timing at 500 MHz.

================================================================================
                            END OF INDEX
================================================================================
